<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<link rel="stylesheet" type="text/css" href="../style.css"/><script src="../highlight.pack.js"></script>
<title>std.allocator</title>
<base href="../"/>
<script src="search.js"></script>
</head>
<body><div class="breadcrumbs">
<table id="results"></table>
<input type="search" id="search" placeholder="Search" onkeyup="searchSubmit(this.value, event)"/>
std.allocator</div>
<div class="section">
<h3>Copyright</h3>
 Andrei Alexandrescu 2013-.


</div>
<div class="section">
<h3>License</h3>
 .


</div>
<div class="section">
<h3>Authors</h3>
 


</div>
<div class="section">
<h3>Source</h3>
 

This module implements untyped composable memory allocators. They are <i>untyped</i> because they deal exclusively in  and have no notion of what
type the memory allocated would be destined for. They are <i>composable</i>
because the included allocators are building blocks that can be assembled in
complex nontrivial allocators.

<p>Unlike the allocators for the C and C++ programming languages, which manage
the allocated size internally, these allocators require that the client
maintains (or knows <i>a priori</i>) the allocation size for each piece of memory
allocated. Put simply, the client must pass the allocated size upon
deallocation. Storing the size in the _allocator has significant negative
performance implications, and is virtually always redundant because client code
needs knowledge of the allocated size in order to avoid buffer overruns. (See
more discussion in a  for sized
deallocation in C++.) For this reason, allocators herein traffic in 
as opposed to .</p>

<p>In order to be usable as an _allocator, a type should implement the
following methods with their respective semantics. Only  and   are required. If any of the other methods is missing, the _allocator
is assumed to not have that capability (for example some allocators do not offer
manual deallocation of memory).</p>



The example below features an allocator modeled after , which uses a battery of free-list allocators spaced so as to keep
internal fragmentation to a minimum. The  definitions specify no
bounds for the freelist because the  does all size selection in
advance.

Sizes through 3584 bytes are handled via freelists of staggered sizes. Sizes
from 3585 bytes through 4072 KB are handled by a  with a
block size of 4 KB. Sizes above that are passed direct to the .

<pre><code>   alias FList = Freelist!(GCAllocator, 0, unbounded);
   alias A = Segregator!(
       8, Freelist!(GCAllocator, 0, 8),
       128, Bucketizer!(FList, 1, 128, 16),
       256, Bucketizer!(FList, 129, 256, 32),
       512, Bucketizer!(FList, 257, 512, 64),
       1024, Bucketizer!(FList, 513, 1024, 128),
       2048, Bucketizer!(FList, 1025, 2048, 256),
       3584, Bucketizer!(FList, 2049, 3584, 512),
       4072 * 1024, CascadingAllocator!(
           () => HeapBlock!(GCAllocator, 4096)(4072 * 1024)),
       GCAllocator
   );
   A tuMalloc;
   auto b = tuMalloc.allocate(500);
   assert(b.length == 500);
   auto c = tuMalloc.allocate(113);
   assert(c.length == 113);
   assert(tuMalloc.expand(c, 14));
   tuMalloc.deallocate(b);
   tuMalloc.deallocate(c);</code></pre>



One allocation pattern used in multithreaded applications is to share memory
across threads, and to deallocate blocks in a different thread than the one that
allocated it.

All allocators in this module accept and return  (as opposed to
). This is because at the time of allocation, deallocation, or
reallocation, the memory is effectively not  (if it were, it would
reveal a bug at the application level).

The issue remains of calling  from a different thread than
the one that allocated . It follows that both threads must have access to
the same instance  of the respective allocator type. By definition of D,
this is possible only if  has the  qualifier. It follows that
the allocator type must implement  and  as  methods. That way, the allocator commits to allowing usable 
instances.

Conversely, allocating memory with one non- allocator, passing it
across threads (by casting the obtained buffer to ), and later
deallocating it in a different thread (either with a different allocator object
or with the same allocator object after casting it to ) is illegal.


</div>
